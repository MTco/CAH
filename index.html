<!DOCTYPE html>
<!-- 
    Cards Against Humanity Online
    © All Rights Reserved - Mathew Tyler
    Website: https://tylerpresident.com | https://fakegov.com
    
    This implementation is the exclusive property of Mathew Tyler.
    All code, design, and implementation rights are reserved.
    Unauthorized reproduction, distribution, or modification is strictly prohibited.
    
    This copyright notice and attribution footer cannot be removed or modified.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cards Against Humanity Online - © Mathew Tyler</title>
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQ2FyZHMgQWdhaW5zdCBIdW1hbml0eSIsInNob3J0X25hbWUiOiJDQUgiLCJkZXNjcmlwdGlvbiI6IkEgZGVjZW50cmFsaXplZCBDYXJkcyBBZ2FpbnN0IEh1bWFuaXR5IGdhbWUiLCJzdGFydF91cmwiOiIuLyIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwMDAwMDAiLCJ0aGVtZV9jb2xvciI6IiMwMDAwMDAiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRJNElpQm9aV2xuYUhROUlqRXlPQ0lpSUhacFpYZENiM2c5SWpBZ01DQXhNamd0TVRJNENYb2c8L25tYm5OK0lFaEVUVlZPYVc1dklPUzlqT1M4ajZpaWEyREFqK0dGc2dnPT0iLCJzaXplcyI6IjUxMng1MTIiLCJ0eXBlIjoiaW1hZ2Uvc3ZnK3htbCJ9XX0=">
    <meta name="theme-color" content="#000000">
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <style>
        :root {
            --bg-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --bg-secondary: rgba(255,255,255,0.1);
            --bg-card: white;
            --bg-black-card: #1a1a1a;
            --text-primary: white;
            --text-secondary: black;
            --text-card: black;
            --text-black-card: white;
            --border-color: #ddd;
            --border-black-card: #333;
            --accent-color: #4CAF50;
            --accent-hover: #45a049;
            --danger-color: #f44336;
            --info-color: #2196F3;
            --shadow-color: rgba(0,0,0,0.1);
            --overlay-color: rgba(0,0,0,0.8);
        }

        /* THEMES */
        [data-theme="midnight-gaming"] {
            --bg-primary: linear-gradient(135deg, #0f1419 0%, #1a1f3a 50%, #2d1b69 100%);
            --bg-secondary: rgba(100, 255, 218, 0.08);
            --bg-card: #1e2139;
            --bg-black-card: #0a0b0f;
            --text-primary: #e1e5eb;
            --text-secondary: #e1e5eb;
            --text-card: #e1e5eb;
            --text-black-card: #64ffda;
            --border-color: #2a2d47;
            --border-black-card: #64ffda;
            --accent-color: #64ffda;
            --accent-hover: #4fd3b8;
            --danger-color: #ff6b9d;
            --info-color: #7c4dff;
            --shadow-color: rgba(0,0,0,0.4);
            --overlay-color: rgba(15,20,25,0.95);
        }
        
        [data-theme="ocean-depths"] {
            --bg-primary: linear-gradient(135deg, #0c4a6e 0%, #164e63 50%, #155e75 100%);
            --bg-secondary: rgba(103, 232, 249, 0.1);
            --bg-card: #1e293b;
            --bg-black-card: #0f172a;
            --text-primary: #f0f9ff;
            --text-secondary: #f0f9ff;
            --text-card: #f0f9ff;
            --text-black-card: #67e8f9;
            --border-color: #334155;
            --border-black-card: #0ea5e9;
            --accent-color: #0ea5e9;
            --accent-hover: #0284c7;
            --danger-color: #f87171;
            --info-color: #3b82f6;
            --shadow-color: rgba(0,0,0,0.3);
            --overlay-color: rgba(12,74,110,0.9);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        #app {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            padding: 20px;
            padding-bottom: 80px;
        }

        .screen {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .card {
            background: var(--bg-card);
            color: var(--text-card);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin: 10px 0;
            box-shadow: 0 4px 6px var(--shadow-color);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px var(--shadow-color);
        }

        .black-card {
            background: var(--bg-black-card);
            color: var(--text-black-card);
            border-color: var(--border-black-card);
            font-size: 1.2em;
            font-weight: bold;
        }

        .white-card {
            cursor: pointer;
            position: relative;
        }

        .white-card.selected {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px var(--accent-color);
        }

        .white-card.submitted {
            opacity: 0.6;
            cursor: not-allowed;
        }

        button {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        button:hover:not(:disabled) {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.danger {
            background: var(--danger-color);
        }

        button.info {
            background: var(--info-color);
        }

        input[type="text"], input[type="number"], select, textarea {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 16px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, var(--accent-color), var(--info-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .menu-grid {
            display: grid;
            gap: 20px;
            max-width: 600px;
            margin: 0 auto;
        }

        .expansion-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .expansion-item {
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .expansion-item.selected {
            background: var(--accent-color);
            color: white;
        }

        .player-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .player-item {
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
            text-align: center;
        }

        .player-item.judge {
            border: 2px solid var(--accent-color);
        }

        .player-item.winner {
            background: var(--accent-color);
            color: white;
        }

        .hand-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }

        .timer {
            font-size: 2em;
            text-align: center;
            margin: 20px 0;
            color: var(--accent-color);
        }

        .timer.warning {
            color: var(--danger-color);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            background: var(--bg-secondary);
            font-size: 0.9em;
            z-index: 100;
        }

        .connection-status.connected {
            background: var(--accent-color);
        }

        .connection-status.connecting {
            background: var(--info-color);
            animation: pulse 2s infinite;
        }

        .connection-status.disconnected {
            background: var(--danger-color);
        }

        #attributionFooter {
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px;
            text-align: center;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 9999;
            transition: all 0.3s ease;
        }

        #attributionFooter.minimized {
            padding: 5px;
            font-size: 0.8em;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--overlay-color);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            color: var(--text-card);
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .qr-container {
            text-align: center;
            margin: 20px 0;
        }

        .qr-container canvas {
            margin: 20px auto;
            border: 4px solid var(--accent-color);
            border-radius: 12px;
        }

        .instructions-visual {
            display: grid;
            gap: 20px;
            margin: 20px 0;
        }

        .instruction-step {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 12px;
        }

        .instruction-step-number {
            font-size: 2em;
            font-weight: bold;
            color: var(--accent-color);
            min-width: 50px;
            text-align: center;
        }

        .game-log {
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
            margin: 10px 0;
            font-size: 0.9em;
        }

        .game-log-entry {
            padding: 5px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .submitted-cards-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .submitted-card-group {
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .submitted-card-group:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px var(--shadow-color);
        }

        .submitted-card-group.selected {
            border: 3px solid var(--accent-color);
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: var(--accent-color);
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .header h1 { font-size: 1.8em; }
            .expansion-grid { grid-template-columns: 1fr; }
            .hand-container { grid-template-columns: 1fr; }
            .submitted-cards-container { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Connection Status -->
        <div id="connectionStatus" class="connection-status disconnected">
            <span id="connectionText">Offline</span>
        </div>

        <!-- Main Menu -->
        <div id="mainMenu" class="screen active">
            <div class="header">
                <h1>Cards Against Humanity</h1>
                <p>Decentralized Online Edition</p>
            </div>
            
            <div class="menu-grid">
                <div class="card">
                    <h2>Player Name</h2>
                    <input type="text" id="playerName" placeholder="Enter your name" maxlength="20">
                </div>
                
                <button onclick="showScreen('hostMenu')">Host Game</button>
                <button onclick="showScreen('joinMenu')">Join Game</button>
                <button onclick="showScreen('expansions')">Select Expansions</button>
                <button onclick="showScreen('customCards')">Custom Cards</button>
                <button onclick="showInstructions()">How to Play</button>
                <button onclick="showSettings()">Settings</button>
            </div>
        </div>

        <!-- Host Menu -->
        <div id="hostMenu" class="screen">
            <div class="header">
                <h1>Host a Game</h1>
            </div>
            
            <div class="card">
                <h3>Game Settings</h3>
                <label>Score Limit:</label>
                <input type="number" id="scoreLimit" value="7" min="1" max="20">
                
                <label>Hand Size:</label>
                <input type="number" id="handSize" value="10" min="5" max="20">
                
                <label>Timer (seconds, 0 = no timer):</label>
                <input type="number" id="timerSeconds" value="60" min="0" max="300">
                
                <label>Signaling Service:</label>
                <select id="signalingService">
                    <option value="jsonbin">JSONBin.io (Recommended)</option>
                    <option value="npoint">npoint.io</option>
                    <option value="github">GitHub Gist</option>
                </select>
            </div>
            
            <button onclick="createRoom()">Create Room</button>
            <button onclick="showScreen('mainMenu')">Back</button>
        </div>

        <!-- Join Menu -->
        <div id="joinMenu" class="screen">
            <div class="header">
                <h1>Join a Game</h1>
            </div>
            
            <div class="card">
                <h3>Enter Room Code</h3>
                <input type="text" id="roomCodeInput" placeholder="Enter 6-digit code" maxlength="6">
            </div>
            
            <button onclick="joinRoom()">Join Room</button>
            <button onclick="scanQRCode()">Scan QR Code</button>
            <button onclick="showScreen('mainMenu')">Back</button>
        </div>

        <!-- Game Room -->
        <div id="gameRoom" class="screen">
            <div class="header">
                <h1>Game Room</h1>
                <p id="roomInfo"></p>
            </div>
            
            <!-- Waiting Phase -->
            <div id="waitingPhase" class="game-phase">
                <div class="card">
                    <h3>Waiting for Players</h3>
                    <div id="playerList" class="player-list"></div>
                    <div id="qrCodeContainer" class="qr-container"></div>
                    <p>Share this code: <strong id="roomCodeDisplay"></strong></p>
                </div>
                <button id="startGameBtn" onclick="startGame()" style="display:none;">Start Game</button>
            </div>
            
            <!-- Playing Phase -->
            <div id="playingPhase" class="game-phase" style="display:none;">
                <div id="timerDisplay" class="timer"></div>
                <div class="card black-card" id="currentBlackCard"></div>
                <h3 id="phaseTitle">Select Your Cards</h3>
                <div id="myHand" class="hand-container"></div>
                <button id="submitCardsBtn" onclick="submitCards()" style="display:none;">Submit Cards</button>
            </div>
            
            <!-- Judging Phase -->
            <div id="judgingPhase" class="game-phase" style="display:none;">
                <div class="card black-card" id="judgingBlackCard"></div>
                <h3 id="judgeInfo">Waiting for Judge to Choose</h3>
                <div id="submittedCards" class="submitted-cards-container"></div>
                <button id="selectWinnerBtn" onclick="selectWinner()" style="display:none;">Select Winner</button>
            </div>
            
            <!-- Results Phase -->
            <div id="resultsPhase" class="game-phase" style="display:none;">
                <div class="card">
                    <h2>Round Winner!</h2>
                    <p id="winnerInfo"></p>
                    <div id="winningCards"></div>
                </div>
                <div class="card">
                    <h3>Scores</h3>
                    <div id="scoreBoard"></div>
                </div>
                <button id="nextRoundBtn" onclick="nextRound()" style="display:none;">Next Round</button>
            </div>
            
            <!-- Game Log -->
            <div class="card">
                <h3>Game Log</h3>
                <div id="gameLog" class="game-log"></div>
            </div>
            
            <button onclick="leaveRoom()" class="danger">Leave Room</button>
        </div>

        <!-- Expansions -->
        <div id="expansions" class="screen">
            <div class="header">
                <h1>Select Expansions</h1>
            </div>
            
            <div class="expansion-grid" id="expansionList"></div>
            
            <button onclick="saveExpansions()">Save & Back</button>
        </div>

        <!-- Custom Cards -->
        <div id="customCards" class="screen">
            <div class="header">
                <h1>Custom Cards</h1>
            </div>
            
            <div class="card">
                <h3>Add Black Card</h3>
                <textarea id="blackCardText" placeholder="Enter black card text. Use ___ for blanks." rows="3"></textarea>
                <button onclick="addCustomCard('black')">Add Black Card</button>
            </div>
            
            <div class="card">
                <h3>Add White Card</h3>
                <input type="text" id="whiteCardText" placeholder="Enter white card text">
                <button onclick="addCustomCard('white')">Add White Card</button>
            </div>
            
            <div class="card">
                <h3>Your Custom Cards</h3>
                <div id="customCardsList"></div>
            </div>
            
            <button onclick="showScreen('mainMenu')">Back</button>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructionsModal" class="modal">
        <div class="modal-content">
            <h2>How to Play Cards Against Humanity</h2>
            
            <div class="card">
                <h3>Overview</h3>
                <p>Cards Against Humanity is a party game for horrible people. Each round, one player asks a question from a black card, and everyone else answers with their funniest white card.</p>
            </div>
            
            <div class="instructions-visual">
                <div class="instruction-step">
                    <div class="instruction-step-number">1</div>
                    <div>
                        <h4>The Judge</h4>
                        <p>Each round, one player is the Judge. The Judge reads the black card aloud.</p>
                    </div>
                </div>
                
                <div class="instruction-step">
                    <div class="instruction-step-number">2</div>
                    <div>
                        <h4>Play White Cards</h4>
                        <p>Everyone else plays white card(s) face down. If the black card has blanks (___), play that many cards in order.</p>
                    </div>
                </div>
                
                <div class="instruction-step">
                    <div class="instruction-step-number">3</div>
                    <div>
                        <h4>Judge Picks Winner</h4>
                        <p>The Judge shuffles all answers, reads them aloud, and picks the funniest one. That player gets a point!</p>
                    </div>
                </div>
                
                <div class="instruction-step">
                    <div class="instruction-step-number">4</div>
                    <div>
                        <h4>New Round</h4>
                        <p>The next player becomes Judge, and everyone draws back up to 10 white cards.</p>
                    </div>
                </div>
            </div>
            
            <div class="card">
                <h3>Special Rules</h3>
                <ul>
                    <li><strong>Pick 2/3:</strong> Some black cards require multiple white cards. Play them in the order the Judge should read them.</li>
                    <li><strong>House Rules:</strong> The host can set custom score limits, hand sizes, and timer settings.</li>
                    <li><strong>Custom Cards:</strong> Add your own horrible cards to make the game even worse!</li>
                </ul>
            </div>
            
            <button onclick="hideInstructions()">Got it!</button>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <h2>Settings</h2>
            
            <div class="card">
                <h3>Theme</h3>
                <select id="themeSelect" onchange="setTheme(this.value)">
                    <option value="midnight-gaming">Midnight Gaming</option>
                    <option value="ocean-depths">Ocean Depths</option>
                </select>
            </div>
            
            <div class="card">
                <h3>Options</h3>
                <label>
                    <input type="checkbox" id="enableCustomCards" checked>
                    Enable Custom Cards
                </label>
                <br>
                <label>
                    <input type="checkbox" id="enableNotifications" checked>
                    Enable Notifications
                </label>
            </div>
            
            <div class="card">
                <h3>Connection Settings</h3>
                <p>STUN Server:</p>
                <select id="stunServer">
                    <option value="stun:stun.l.google.com:19302">Google STUN</option>
                    <option value="stun:stun1.l.google.com:19302">Google STUN 1</option>
                    <option value="stun:stun2.l.google.com:19302">Google STUN 2</option>
                </select>
            </div>
            
            <button onclick="hideSettings()">Close</button>
        </div>
    </div>

    <!-- QR Scanner Modal -->
    <div id="qrModal" class="modal">
        <div class="modal-content">
            <h2>Scan QR Code</h2>
            <video id="qrVideo" style="width: 100%; max-width: 400px;"></video>
            <canvas id="qrCanvas" style="display: none;"></canvas>
            <button onclick="stopQRScanner()">Cancel</button>
        </div>
    </div>

    <!-- Attribution Footer -->
    <footer id="attributionFooter" onclick="toggleAttribution()">
        <div>© All Rights Reserved - Mathew Tyler | https://tylerpresident.com | https://fakegov.com</div>
        <small>Click to minimize/expand</small>
    </footer>

    <script>
        // ===== GAME STATE =====
        const gameState = {
            roomCode: null,
            isHost: false,
            players: new Map(), // playerId -> playerInfo
            currentBlackCard: null,
            submittedCards: new Map(), // playerId -> cards
            scores: new Map(), // playerId -> score
            selectedExpansions: ['base'],
            gamePhase: 'waiting', // waiting, playing, judging, results
            currentJudge: null,
            myHand: [],
            selectedCards: [],
            roundWinner: null,
            settings: {
                scoreLimit: 7,
                handSize: 10,
                timerSeconds: 60
            },
            timer: null,
            timeRemaining: 0
        };

        // ===== APP STATE =====
        const appState = {
            myId: generateId(),
            myName: 'Player',
            peer: null,
            connections: new Map(), // peerId -> RTCPeerConnection
            dataChannels: new Map(), // peerId -> RTCDataChannel
            signalingService: 'jsonbin',
            notifications: { enabled: true, audio: true, visual: true },
            qrScanner: null,
            reconnectAttempts: 0,
            maxReconnectAttempts: 5,
            heartbeatInterval: null
        };

        // ===== WEBRTC CONFIG =====
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        // ===== SIGNALING SERVICES CONFIG =====
        const signalingConfig = {
            jsonbin: {
                baseUrl: 'https://api.jsonbin.io/v3',
                apiKey: '$2b$10$' + btoa(Date.now()).substring(0, 20), // Generate pseudo-key
                collection: 'cah-rooms'
            },
            npoint: {
                baseUrl: 'https://api.npoint.io',
                endpoint: null // Will be created dynamically
            },
            github: {
                baseUrl: 'https://api.github.com/gists',
                token: null // User would need to provide their own token
            }
        };

        // ===== CARD DATABASE =====
        const cardDatabase = {
            base: {
                black: [
                    { text: "Why can't I sleep at night?", pick: 1 },
                    { text: "___ + ___ = ___.", pick: 3 },
                    { text: "What's that smell?", pick: 1 },
                    { text: "I got 99 problems but ___ ain't one.", pick: 1 },
                    { text: "Maybe she's born with it. Maybe it's ___.", pick: 1 },
                    { text: "What's the next Happy Meal® toy?", pick: 1 },
                    { text: "Here is the church. Here is the steeple. Open the doors and there is ___.", pick: 1 },
                    { text: "It's a pity that kids these days are all getting involved with ___.", pick: 1 },
                    { text: "During sex, I like to think about ___.", pick: 1 },
                    { text: "What ended my last relationship?", pick: 1 },
                    { text: "MTV's new reality show features eight washed-up celebrities living with ___.", pick: 1 },
                    { text: "I drink to forget ___.", pick: 1 },
                    { text: "What is Batman's guilty pleasure?", pick: 1 },
                    { text: "This is the way the world ends. Not with a bang but with ___.", pick: 1 },
                    { text: "What's a girl's best friend?", pick: 1 },
                    { text: "___ is a slippery slope that leads to ___.", pick: 2 },
                    { text: "In M. Night Shyamalan's new movie, Bruce Willis discovers that ___ had really been ___ all along.", pick: 2 },
                    { text: "___. High five, bro.", pick: 1 },
                    { text: "Instead of coal, Santa now gives the bad children ___.", pick: 1 },
                    { text: "Next from J.K. Rowling: Harry Potter and the Chamber of ___.", pick: 1 }
                ],
                white: [
                    "Being on fire",
                    "Racism",
                    "Old-people smell",
                    "A micropenis",
                    "Women in yogurt commercials",
                    "Classist undertones",
                    "Not giving a shit about the Third World",
                    "Sexting",
                    "Roofies",
                    "A windmill full of corpses",
                    "An Oedipus complex",
                    "A mime having a stroke",
                    "Flying sex snakes",
                    "A balanced breakfast",
                    "Actually getting to know each other",
                    "Science",
                    "Explosions",
                    "Friendship",
                    "Agriculture",
                    "A falcon with a cap on its head",
                    "Having anuses for eyes",
                    "Republicans",
                    "The invisible hand",
                    "Heteronormativity",
                    "Cuddling",
                    "Free samples",
                    "Being marginalized",
                    "Dying of dysentery",
                    "My humps",
                    "The magic of live theatre"
                ]
            },
            expansion1: {
                black: [
                    { text: "Lifetime® presents ___, the story of ___.", pick: 2 },
                    { text: "What's my secret power?", pick: 1 },
                    { text: "What's there a ton of in heaven?", pick: 1 },
                    { text: "What would grandma find disturbing, yet oddly charming?", pick: 1 }
                ],
                white: [
                    "The Pope",
                    "Flying sex snakes",
                    "Foreskin",
                    "Viagra",
                    "Getting so angry that you pop a boner",
                    "Amputees",
                    "Passive-aggressive Post-it notes",
                    "The gay agenda"
                ]
            }
        };

        // ===== INITIALIZATION =====
        function initializeApp() {
            initializeCopyright();
            loadPlayerName();
            loadCustomCards();
            loadSettings();
            loadTheme();
            initializeAttribution();
            protectAttribution();
            observeAttribution();
            initializeExpansions();
            updateConnectionStatus('disconnected');
            setupMessageHandlers();
        }

        // ===== WEBRTC FUNCTIONS =====
        async function createRoom() {
            const playerName = document.getElementById('playerName').value.trim();
            if (!playerName) {
                alert('Please enter your name');
                return;
            }
            
            appState.myName = playerName;
            savePlayerName(playerName);
            gameState.isHost = true;
            gameState.roomCode = generateRoomCode();
            
            // Get game settings
            gameState.settings.scoreLimit = parseInt(document.getElementById('scoreLimit').value);
            gameState.settings.handSize = parseInt(document.getElementById('handSize').value);
            gameState.settings.timerSeconds = parseInt(document.getElementById('timerSeconds').value);
            
            // Add self to players
            gameState.players.set(appState.myId, {
                id: appState.myId,
                name: appState.myName,
                isHost: true,
                connected: true
            });
            gameState.scores.set(appState.myId, 0);
            
            try {
                await publishRoom();
                showScreen('gameRoom');
                updateRoomInfo();
                updatePlayerList();
                generateQRCode();
                startHeartbeat();
                addGameLog('Room created! Waiting for players...');
            } catch (error) {
                console.error('Failed to create room:', error);
                alert('Failed to create room. Please try again.');
            }
        }

        async function joinRoom() {
            const playerName = document.getElementById('playerName').value.trim();
            const roomCode = document.getElementById('roomCodeInput').value.trim().toUpperCase();
            
            if (!playerName || !roomCode) {
                alert('Please enter your name and room code');
                return;
            }
            
            if (roomCode.length !== 6) {
                alert('Room code must be 6 characters');
                return;
            }
            
            appState.myName = playerName;
            savePlayerName(playerName);
            gameState.roomCode = roomCode;
            gameState.isHost = false;
            
            try {
                updateConnectionStatus('connecting');
                const roomData = await fetchRoomData(roomCode);
                
                if (!roomData) {
                    throw new Error('Room not found');
                }
                
                // Connect to host
                await connectToPeer(roomData.hostId, true);
                
                showScreen('gameRoom');
                updateRoomInfo();
                startHeartbeat();
            } catch (error) {
                console.error('Failed to join room:', error);
                alert('Failed to join room. Please check the room code and try again.');
                updateConnectionStatus('disconnected');
            }
        }

        async function connectToPeer(peerId, isInitiator = false) {
            if (appState.connections.has(peerId)) {
                return; // Already connected
            }
            
            const pc = new RTCPeerConnection(rtcConfig);
            appState.connections.set(peerId, pc);
            
            // Create data channel
            let dataChannel;
            if (isInitiator) {
                dataChannel = pc.createDataChannel('game');
                setupDataChannel(dataChannel, peerId);
            }
            
            // Handle ICE candidates
            pc.onicecandidate = async (event) => {
                if (event.candidate) {
                    await sendSignalingMessage(peerId, {
                        type: 'ice-candidate',
                        candidate: event.candidate,
                        from: appState.myId
                    });
                }
            };
            
            // Handle data channel
            pc.ondatachannel = (event) => {
                setupDataChannel(event.channel, peerId);
            };
            
            // Handle connection state
            pc.onconnectionstatechange = () => {
                console.log(`Connection state with ${peerId}: ${pc.connectionState}`);
                if (pc.connectionState === 'connected') {
                    updateConnectionStatus('connected');
                } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    handlePeerDisconnect(peerId);
                }
            };
            
            if (isInitiator) {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                await sendSignalingMessage(peerId, {
                    type: 'offer',
                    offer: offer,
                    from: appState.myId
                });
            }
            
            return pc;
        }

        function setupDataChannel(channel, peerId) {
            channel.onopen = () => {
                console.log(`Data channel opened with ${peerId}`);
                appState.dataChannels.set(peerId, channel);
                
                // Send initial handshake
                sendToPeer(peerId, {
                    type: 'handshake',
                    player: {
                        id: appState.myId,
                        name: appState.myName,
                        isHost: gameState.isHost
                    }
                });
            };
            
            channel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handlePeerMessage(data, peerId);
            };
            
            channel.onclose = () => {
                console.log(`Data channel closed with ${peerId}`);
                appState.dataChannels.delete(peerId);
            };
            
            channel.onerror = (error) => {
                console.error(`Data channel error with ${peerId}:`, error);
            };
        }

        // ===== SIGNALING FUNCTIONS =====
        async function publishRoom() {
            const roomData = {
                code: gameState.roomCode,
                hostId: appState.myId,
                created: Date.now(),
                expansions: gameState.selectedExpansions,
                settings: gameState.settings
            };
            
            switch (appState.signalingService) {
                case 'jsonbin':
                    return await publishToJSONBin(roomData);
                case 'npoint':
                    return await publishToNPoint(roomData);
                case 'github':
                    return await publishToGitHub(roomData);
                default:
                    throw new Error('Unknown signaling service');
            }
        }

        async function publishToJSONBin(roomData) {
            try {
                const response = await fetch(`${signalingConfig.jsonbin.baseUrl}/b`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-Master-Key': signalingConfig.jsonbin.apiKey,
                        'X-Collection-Id': signalingConfig.jsonbin.collection,
                        'X-Bin-Name': `CAH-Room-${gameState.roomCode}`
                    },
                    body: JSON.stringify(roomData)
                });
                
                if (!response.ok) throw new Error('Failed to publish room');
                
                const result = await response.json();
                localStorage.setItem(`room-${gameState.roomCode}`, result.metadata.id);
                return result;
            } catch (error) {
                console.error('JSONBin publish error:', error);
                // Fallback to local storage for demo
                localStorage.setItem(`room-${gameState.roomCode}`, JSON.stringify(roomData));
                return roomData;
            }
        }

        async function publishToNPoint(roomData) {
            try {
                const response = await fetch(`${signalingConfig.npoint.baseUrl}/schema`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ schema: roomData })
                });
                
                if (!response.ok) throw new Error('Failed to create npoint');
                
                const endpoint = response.headers.get('Location');
                signalingConfig.npoint.endpoint = endpoint;
                localStorage.setItem(`room-${gameState.roomCode}`, endpoint);
                return roomData;
            } catch (error) {
                console.error('NPoint publish error:', error);
                // Fallback to local storage
                localStorage.setItem(`room-${gameState.roomCode}`, JSON.stringify(roomData));
                return roomData;
            }
        }

        async function publishToGitHub(roomData) {
            // GitHub requires authentication - for demo we'll use local storage
            console.log('GitHub signaling requires authentication token');
            localStorage.setItem(`room-${gameState.roomCode}`, JSON.stringify(roomData));
            return roomData;
        }

        async function fetchRoomData(roomCode) {
            // First check local storage (for demo/fallback)
            const localData = localStorage.getItem(`room-${roomCode}`);
            if (localData) {
                try {
                    return JSON.parse(localData);
                } catch {
                    // Continue to remote fetch
                }
            }
            
            // In production, fetch from the signaling service
            // For now, return null if not found locally
            return null;
        }

        async function sendSignalingMessage(targetId, message) {
            // In production, this would send through the signaling service
            // For demo, we'll use local storage events
            const key = `signal-${targetId}-${Date.now()}`;
            localStorage.setItem(key, JSON.stringify(message));
            
            // Clean up old messages
            setTimeout(() => localStorage.removeItem(key), 5000);
        }

        // ===== MESSAGE HANDLING =====
        function setupMessageHandlers() {
            // Listen for signaling messages via storage events
            window.addEventListener('storage', (event) => {
                if (event.key && event.key.startsWith('signal-')) {
                    try {
                        const message = JSON.parse(event.newValue);
                        handleSignalingMessage(message);
                    } catch (error) {
                        console.error('Failed to parse signaling message:', error);
                    }
                }
            });
        }

        async function handleSignalingMessage(message) {
            if (message.from === appState.myId) return; // Ignore own messages
            
            switch (message.type) {
                case 'offer':
                    await handleOffer(message);
                    break;
                case 'answer':
                    await handleAnswer(message);
                    break;
                case 'ice-candidate':
                    await handleIceCandidate(message);
                    break;
            }
        }

        async function handleOffer(message) {
            const pc = await connectToPeer(message.from);
            await pc.setRemoteDescription(message.offer);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            
            await sendSignalingMessage(message.from, {
                type: 'answer',
                answer: answer,
                from: appState.myId
            });
        }

        async function handleAnswer(message) {
            const pc = appState.connections.get(message.from);
            if (pc) {
                await pc.setRemoteDescription(message.answer);
            }
        }

        async function handleIceCandidate(message) {
            const pc = appState.connections.get(message.from);
            if (pc) {
                await pc.addIceCandidate(message.candidate);
            }
        }

        function handlePeerMessage(data, peerId) {
            switch (data.type) {
                case 'handshake':
                    handleHandshake(data, peerId);
                    break;
                case 'game-state':
                    handleGameStateUpdate(data);
                    break;
                case 'submit-cards':
                    handleCardSubmission(data);
                    break;
                case 'select-winner':
                    handleWinnerSelection(data);
                    break;
                case 'chat':
                    addGameLog(`${data.playerName}: ${data.message}`);
                    break;
                case 'heartbeat':
                    // Update last seen time
                    break;
            }
        }

        function handleHandshake(data, peerId) {
            // Add player to game
            gameState.players.set(data.player.id, {
                ...data.player,
                connected: true
            });
            gameState.scores.set(data.player.id, 0);
            
            updatePlayerList();
            addGameLog(`${data.player.name} joined the game!`);
            
            // If we're host, send current game state
            if (gameState.isHost) {
                sendToPeer(peerId, {
                    type: 'game-state',
                    gameState: {
                        players: Array.from(gameState.players.values()),
                        scores: Array.from(gameState.scores.entries()),
                        phase: gameState.gamePhase,
                        currentJudge: gameState.currentJudge,
                        currentBlackCard: gameState.currentBlackCard,
                        settings: gameState.settings
                    }
                });
                
                // Broadcast to all other players
                broadcast({
                    type: 'player-joined',
                    player: data.player
                }, peerId);
            }
        }

        function handleGameStateUpdate(data) {
            // Update local game state
            data.gameState.players.forEach(player => {
                gameState.players.set(player.id, player);
            });
            data.gameState.scores.forEach(([id, score]) => {
                gameState.scores.set(id, score);
            });
            gameState.gamePhase = data.gameState.phase;
            gameState.currentJudge = data.gameState.currentJudge;
            gameState.currentBlackCard = data.gameState.currentBlackCard;
            gameState.settings = data.gameState.settings;
            
            updatePlayerList();
            updateGamePhase();
        }

        // ===== GAME LOGIC =====
        function startGame() {
            if (!gameState.isHost) return;
            if (gameState.players.size < 3) {
                alert('Need at least 3 players to start!');
                return;
            }
            
            addGameLog('Game started!');
            gameState.gamePhase = 'playing';
            
            // Initialize hands
            initializeHands();
            
            // Start first round
            startNewRound();
            
            // Broadcast game start
            broadcast({
                type: 'game-start',
                hands: Array.from(gameState.players.keys()).map(id => ({
                    playerId: id,
                    cards: id === appState.myId ? gameState.myHand : []
                }))
            });
        }

        function initializeHands() {
            const whiteCards = getAllWhiteCards();
            const shuffled = shuffleArray([...whiteCards]);
            
            gameState.players.forEach((player, playerId) => {
                if (playerId === appState.myId) {
                    gameState.myHand = shuffled.splice(0, gameState.settings.handSize);
                }
            });
        }

        function startNewRound() {
            // Clear previous round data
            gameState.submittedCards.clear();
            gameState.selectedCards = [];
            gameState.roundWinner = null;
            
            // Select next judge
            const playerIds = Array.from(gameState.players.keys());
            const currentIndex = gameState.currentJudge ? playerIds.indexOf(gameState.currentJudge) : -1;
            gameState.currentJudge = playerIds[(currentIndex + 1) % playerIds.length];
            
            // Draw black card
            const blackCards = getAllBlackCards();
            gameState.currentBlackCard = blackCards[Math.floor(Math.random() * blackCards.length)];
            
            // Update UI
            updateGamePhase();
            
            // Start timer
            if (gameState.settings.timerSeconds > 0) {
                startTimer(gameState.settings.timerSeconds);
            }
            
            // Broadcast round start
            broadcast({
                type: 'round-start',
                judge: gameState.currentJudge,
                blackCard: gameState.currentBlackCard
            });
            
            addGameLog(`New round! ${gameState.players.get(gameState.currentJudge).name} is the judge.`);
        }

        function submitCards() {
            if (gameState.selectedCards.length !== gameState.currentBlackCard.pick) {
                alert(`Please select ${gameState.currentBlackCard.pick} card(s)`);
                return;
            }
            
            // Remove selected cards from hand
            gameState.selectedCards.forEach(card => {
                const index = gameState.myHand.indexOf(card);
                if (index > -1) {
                    gameState.myHand.splice(index, 1);
                }
            });
            
            // Submit cards
            const submission = {
                playerId: appState.myId,
                cards: gameState.selectedCards
            };
            
            if (gameState.isHost) {
                gameState.submittedCards.set(appState.myId, gameState.selectedCards);
                checkAllSubmitted();
            } else {
                sendToHost({
                    type: 'submit-cards',
                    submission: submission
                });
            }
            
            // Update UI
            document.getElementById('submitCardsBtn').style.display = 'none';
            document.querySelectorAll('.white-card').forEach(card => {
                card.classList.add('submitted');
            });
            
            addGameLog('Cards submitted!');
        }

        function handleCardSubmission(data) {
            gameState.submittedCards.set(data.submission.playerId, data.submission.cards);
            checkAllSubmitted();
        }

        function checkAllSubmitted() {
            const activePlayers = Array.from(gameState.players.keys()).filter(id => id !== gameState.currentJudge);
            const allSubmitted = activePlayers.every(id => gameState.submittedCards.has(id));
            
            if (allSubmitted) {
                moveToJudgingPhase();
            }
        }

        function moveToJudgingPhase() {
            gameState.gamePhase = 'judging';
            clearTimer();
            
            // Shuffle submissions
            const submissions = Array.from(gameState.submittedCards.entries()).map(([playerId, cards]) => ({
                playerId,
                cards
            }));
            const shuffled = shuffleArray(submissions);
            
            // Broadcast judging phase
            broadcast({
                type: 'judging-phase',
                submissions: shuffled.map(s => s.cards) // Don't reveal player IDs
            });
            
            updateGamePhase();
            addGameLog('All cards submitted! Time to judge...');
        }

        function selectWinner() {
            const selected = document.querySelector('.submitted-card-group.selected');
            if (!selected) {
                alert('Please select a winning card!');
                return;
            }
            
            const winnerIndex = parseInt(selected.dataset.index);
            const submissions = Array.from(gameState.submittedCards.entries());
            const winner = submissions[winnerIndex];
            
            if (gameState.isHost) {
                handleWinnerSelection({ winnerId: winner[0] });
            } else {
                sendToHost({
                    type: 'select-winner',
                    winnerId: winner[0]
                });
            }
        }

        function handleWinnerSelection(data) {
            gameState.roundWinner = data.winnerId;
            
            // Update score
            const currentScore = gameState.scores.get(data.winnerId) || 0;
            gameState.scores.set(data.winnerId, currentScore + 1);
            
            // Move to results phase
            gameState.gamePhase = 'results';
            
            // Broadcast results
            broadcast({
                type: 'round-results',
                winnerId: data.winnerId,
                winningCards: gameState.submittedCards.get(data.winnerId),
                scores: Array.from(gameState.scores.entries())
            });
            
            updateGamePhase();
            
            const winner = gameState.players.get(data.winnerId);
            addGameLog(`${winner.name} wins the round!`);
            
            // Check for game winner
            if (currentScore + 1 >= gameState.settings.scoreLimit) {
                endGame(data.winnerId);
            }
        }

        function nextRound() {
            if (!gameState.isHost) return;
            
            // Draw new cards
            drawNewCards();
            
            // Start new round
            startNewRound();
        }

        function drawNewCards() {
            const whiteCards = getAllWhiteCards();
            const needed = gameState.settings.handSize - gameState.myHand.length;
            
            for (let i = 0; i < needed; i++) {
                const randomCard = whiteCards[Math.floor(Math.random() * whiteCards.length)];
                gameState.myHand.push(randomCard);
            }
        }

        function endGame(winnerId) {
            const winner = gameState.players.get(winnerId);
            addGameLog(`🎉 ${winner.name} wins the game with ${gameState.scores.get(winnerId)} points!`);
            
            // Show final scores
            setTimeout(() => {
                if (confirm(`${winner.name} wins! Play again?`)) {
                    resetGame();
                } else {
                    leaveRoom();
                }
            }, 2000);
        }

        function resetGame() {
            gameState.scores.clear();
            gameState.players.forEach((player, id) => {
                gameState.scores.set(id, 0);
            });
            gameState.gamePhase = 'waiting';
            gameState.currentJudge = null;
            gameState.myHand = [];
            updateGamePhase();
            updatePlayerList();
        }

        // ===== UI UPDATE FUNCTIONS =====
        function updateGamePhase() {
            // Hide all phases
            document.querySelectorAll('.game-phase').forEach(phase => {
                phase.style.display = 'none';
            });
            
            // Show current phase
            switch (gameState.gamePhase) {
                case 'waiting':
                    document.getElementById('waitingPhase').style.display = 'block';
                    if (gameState.isHost && gameState.players.size >= 3) {
                        document.getElementById('startGameBtn').style.display = 'block';
                    }
                    break;
                    
                case 'playing':
                    document.getElementById('playingPhase').style.display = 'block';
                    updatePlayingPhase();
                    break;
                    
                case 'judging':
                    document.getElementById('judgingPhase').style.display = 'block';
                    updateJudgingPhase();
                    break;
                    
                case 'results':
                    document.getElementById('resultsPhase').style.display = 'block';
                    updateResultsPhase();
                    break;
            }
        }

        function updatePlayingPhase() {
            // Update black card
            const blackCardEl = document.getElementById('currentBlackCard');
            blackCardEl.textContent = gameState.currentBlackCard.text;
            
            // Update phase title
            const isJudge = appState.myId === gameState.currentJudge;
            document.getElementById('phaseTitle').textContent = isJudge ? 
                'You are the judge this round!' : 
                `Select ${gameState.currentBlackCard.pick} card(s)`;
            
            // Update hand
            const handEl = document.getElementById('myHand');
            handEl.innerHTML = '';
            
            if (!isJudge) {
                gameState.myHand.forEach((card, index) => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card white-card';
                    cardEl.textContent = card;
                    cardEl.onclick = () => toggleCardSelection(card, cardEl);
                    handEl.appendChild(cardEl);
                });
                
                document.getElementById('submitCardsBtn').style.display = 'block';
            }
        }

        function updateJudgingPhase() {
            // Update black card
            document.getElementById('judgingBlackCard').textContent = gameState.currentBlackCard.text;
            
            // Update judge info
            const isJudge = appState.myId === gameState.currentJudge;
            const judge = gameState.players.get(gameState.currentJudge);
            document.getElementById('judgeInfo').textContent = isJudge ?
                'Choose the funniest card!' :
                `${judge.name} is choosing the winner...`;
            
            // Display submissions
            const container = document.getElementById('submittedCards');
            container.innerHTML = '';
            
            const submissions = Array.from(gameState.submittedCards.values());
            submissions.forEach((cards, index) => {
                const groupEl = document.createElement('div');
                groupEl.className = 'submitted-card-group';
                groupEl.dataset.index = index;
                
                cards.forEach(card => {
                    const cardEl = document.createElement('div');
                    cardEl.className = 'card';
                    cardEl.textContent = card;
                    groupEl.appendChild(cardEl);
                });
                
                if (isJudge) {
                    groupEl.onclick = () => {
                        document.querySelectorAll('.submitted-card-group').forEach(g => {
                            g.classList.remove('selected');
                        });
                        groupEl.classList.add('selected');
                    };
                }
                
                container.appendChild(groupEl);
            });
            
            if (isJudge) {
                document.getElementById('selectWinnerBtn').style.display = 'block';
            }
        }

        function updateResultsPhase() {
            const winner = gameState.players.get(gameState.roundWinner);
            document.getElementById('winnerInfo').textContent = `${winner.name} wins this round!`;
            
            // Show winning cards
            const winningCards = gameState.submittedCards.get(gameState.roundWinner);
            const winningCardsEl = document.getElementById('winningCards');
            winningCardsEl.innerHTML = winningCards.map(card => 
                `<div class="card">${card}</div>`
            ).join('');
            
            // Update scoreboard
            updateScoreboard();
            
            // Show next round button for host
            if (gameState.isHost) {
                document.getElementById('nextRoundBtn').style.display = 'block';
            }
        }

        function updateScoreboard() {
            const scoreboardEl = document.getElementById('scoreBoard');
            const scores = Array.from(gameState.scores.entries())
                .sort((a, b) => b[1] - a[1])
                .map(([playerId, score]) => {
                    const player = gameState.players.get(playerId);
                    return `<div class="player-item ${score >= gameState.settings.scoreLimit ? 'winner' : ''}">
                        ${player.name}: ${score} points
                    </div>`;
                })
                .join('');
            scoreboardEl.innerHTML = scores;
        }

        function toggleCardSelection(card, element) {
            const index = gameState.selectedCards.indexOf(card);
            
            if (index > -1) {
                gameState.selectedCards.splice(index, 1);
                element.classList.remove('selected');
            } else {
                if (gameState.selectedCards.length < gameState.currentBlackCard.pick) {
                    gameState.selectedCards.push(card);
                    element.classList.add('selected');
                } else {
                    alert(`You can only select ${gameState.currentBlackCard.pick} card(s)`);
                }
            }
        }

        // ===== UTILITY FUNCTIONS =====
        function generateId() {
            return Math.random().toString(36).substring(2) + Date.now().toString(36);
        }

        function generateRoomCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function getAllWhiteCards() {
            let cards = [];
            gameState.selectedExpansions.forEach(exp => {
                const deck = cardDatabase[exp];
                if (deck && deck.white) cards.push(...deck.white);
            });
            if (getSettings().enableCustomCards) {
                cards.push(...getCustomCards().white);
            }
            return cards.length > 0 ? cards : ['No cards available'];
        }

        function getAllBlackCards() {
            let cards = [];
            gameState.selectedExpansions.forEach(exp => {
                const deck = cardDatabase[exp];
                if (deck && deck.black) cards.push(...deck.black);
            });
            if (getSettings().enableCustomCards) {
                cards.push(...getCustomCards().black);
            }
            return cards.length > 0 ? cards : [{ text: 'No cards available', pick: 1 }];
        }

        // ===== COMMUNICATION FUNCTIONS =====
        function sendToPeer(peerId, data) {
            const channel = appState.dataChannels.get(peerId);
            if (channel && channel.readyState === 'open') {
                channel.send(JSON.stringify(data));
            }
        }

        function sendToHost(data) {
            const hostId = Array.from(gameState.players.values()).find(p => p.isHost)?.id;
            if (hostId) {
                sendToPeer(hostId, data);
            }
        }

        function broadcast(data, excludeId = null) {
            appState.dataChannels.forEach((channel, peerId) => {
                if (peerId !== excludeId && channel.readyState === 'open') {
                    channel.send(JSON.stringify(data));
                }
            });
        }

        // ===== TIMER FUNCTIONS =====
        function startTimer(seconds) {
            clearTimer();
            gameState.timeRemaining = seconds;
            updateTimer();
            
            gameState.timer = setInterval(() => {
                gameState.timeRemaining--;
                updateTimer();
                
                if (gameState.timeRemaining <= 0) {
                    clearTimer();
                    handleTimerExpired();
                }
            }, 1000);
        }

        function clearTimer() {
            if (gameState.timer) {
                clearInterval(gameState.timer);
                gameState.timer = null;
            }
            document.getElementById('timerDisplay').textContent = '';
        }

        function updateTimer() {
            const timerEl = document.getElementById('timerDisplay');
            timerEl.textContent = `Time: ${gameState.timeRemaining}s`;
            timerEl.className = gameState.timeRemaining <= 10 ? 'timer warning' : 'timer';
        }

        function handleTimerExpired() {
            if (gameState.gamePhase === 'playing' && gameState.isHost) {
                // Auto-submit for players who haven't submitted
                const activePlayers = Array.from(gameState.players.keys()).filter(id => id !== gameState.currentJudge);
                activePlayers.forEach(playerId => {
                    if (!gameState.submittedCards.has(playerId)) {
                        // Submit random cards
                        const randomCards = [];
                        for (let i = 0; i < gameState.currentBlackCard.pick; i++) {
                            randomCards.push('No submission');
                        }
                        gameState.submittedCards.set(playerId, randomCards);
                    }
                });
                
                moveToJudgingPhase();
            }
        }

        // ===== UI HELPER FUNCTIONS =====
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            const screen = document.getElementById(screenId);
            if (screen) {
                screen.classList.add('active');
            }
        }

        function updateRoomInfo() {
            document.getElementById('roomInfo').textContent = 
                `Room Code: ${gameState.roomCode} | Players: ${gameState.players.size}`;
            document.getElementById('roomCodeDisplay').textContent = gameState.roomCode;
        }

        function updatePlayerList() {
            const container = document.getElementById('playerList');
            container.innerHTML = Array.from(gameState.players.values())
                .map(player => `
                    <div class="player-item ${player.id === gameState.currentJudge ? 'judge' : ''}">
                        ${player.name}
                        ${player.isHost ? '👑' : ''}
                        ${player.id === gameState.currentJudge ? '⚖️' : ''}
                        ${!player.connected ? '❌' : ''}
                    </div>
                `)
                .join('');
        }

        function updateConnectionStatus(status) {
            const statusEl = document.getElementById('connectionStatus');
            const textEl = document.getElementById('connectionText');
            
            statusEl.className = `connection-status ${status}`;
            
            switch (status) {
                case 'connected':
                    textEl.textContent = 'Connected';
                    break;
                case 'connecting':
                    textEl.innerHTML = 'Connecting <span class="loading-spinner"></span>';
                    break;
                case 'disconnected':
                    textEl.textContent = 'Offline';
                    break;
            }
        }

        function addGameLog(message) {
            const logEl = document.getElementById('gameLog');
            const entry = document.createElement('div');
            entry.className = 'game-log-entry';
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function generateQRCode() {
            const container = document.getElementById('qrCodeContainer');
            container.innerHTML = '<canvas id="qrCode"></canvas>';
            
            const joinUrl = `${window.location.origin}${window.location.pathname}?room=${gameState.roomCode}`;
            QRCode.toCanvas(document.getElementById('qrCode'), joinUrl, {
                width: 200,
                margin: 2,
                color: {
                    dark: '#000000',
                    light: '#FFFFFF'
                }
            });
        }

        function leaveRoom() {
            if (confirm('Are you sure you want to leave the game?')) {
                // Clean up connections
                appState.dataChannels.forEach(channel => channel.close());
                appState.connections.forEach(conn => conn.close());
                appState.dataChannels.clear();
                appState.connections.clear();
                
                // Clear heartbeat
                if (appState.heartbeatInterval) {
                    clearInterval(appState.heartbeatInterval);
                }
                
                // Reset game state
                gameState.roomCode = null;
                gameState.isHost = false;
                gameState.players.clear();
                gameState.scores.clear();
                gameState.myHand = [];
                
                updateConnectionStatus('disconnected');
                showScreen('mainMenu');
            }
        }

        // ===== HEARTBEAT & RECONNECTION =====
        function startHeartbeat() {
            appState.heartbeatInterval = setInterval(() => {
                broadcast({ type: 'heartbeat', from: appState.myId });
            }, 5000);
        }

        function handlePeerDisconnect(peerId) {
            const player = gameState.players.get(peerId);
            if (player) {
                player.connected = false;
                updatePlayerList();
                addGameLog(`${player.name} disconnected`);
                
                // Start reconnection attempts
                attemptReconnection(peerId);
            }
        }

        async function attemptReconnection(peerId) {
            if (appState.reconnectAttempts >= appState.maxReconnectAttempts) {
                const player = gameState.players.get(peerId);
                addGameLog(`Failed to reconnect to ${player.name}`);
                return;
            }
            
            appState.reconnectAttempts++;
            
            setTimeout(async () => {
                try {
                    await connectToPeer(peerId, true);
                } catch (error) {
                    console.error('Reconnection failed:', error);
                    attemptReconnection(peerId);
                }
            }, 2000 * appState.reconnectAttempts);
        }

        // ===== SETTINGS & STORAGE =====
        function showSettings() {
            document.getElementById('settingsModal').classList.add('active');
            document.getElementById('themeSelect').value = localStorage.getItem('cah-theme') || 'midnight-gaming';
            document.getElementById('enableCustomCards').checked = getSettings().enableCustomCards;
            document.getElementById('enableNotifications').checked = appState.notifications.enabled;
        }

        function hideSettings() {
            document.getElementById('settingsModal').classList.remove('active');
            const settings = {
                enableCustomCards: document.getElementById('enableCustomCards').checked
            };
            localStorage.setItem('cah-settings', JSON.stringify(settings));
            
            appState.notifications.enabled = document.getElementById('enableNotifications').checked;
            localStorage.setItem('cah-notifications', JSON.stringify(appState.notifications));
        }

        function setTheme(theme) {
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('cah-theme', theme);
        }

        function showInstructions() {
            document.getElementById('instructionsModal').classList.add('active');
        }

        function hideInstructions() {
            document.getElementById('instructionsModal').classList.remove('active');
        }

        // ===== EXPANSION FUNCTIONS =====
        function initializeExpansions() {
            const container = document.getElementById('expansionList');
            const saved = JSON.parse(localStorage.getItem('cah-expansions') || '["base"]');
            gameState.selectedExpansions = saved;
            
            const expansions = Object.keys(cardDatabase);
            container.innerHTML = expansions.map(exp => `
                <div class="expansion-item ${gameState.selectedExpansions.includes(exp) ? 'selected' : ''}" 
                     onclick="toggleExpansion('${exp}')">
                    ${exp.charAt(0).toUpperCase() + exp.slice(1).replace(/(\d+)/, ' $1')}
                </div>
            `).join('');
        }

        function toggleExpansion(expansion) {
            const index = gameState.selectedExpansions.indexOf(expansion);
            if (index > -1) {
                gameState.selectedExpansions.splice(index, 1);
            } else {
                gameState.selectedExpansions.push(expansion);
            }
            initializeExpansions();
        }

        function saveExpansions() {
            if (gameState.selectedExpansions.length === 0) {
                alert('Please select at least one expansion');
                return;
            }
            localStorage.setItem('cah-expansions', JSON.stringify(gameState.selectedExpansions));
            showScreen('mainMenu');
        }

        // ===== CUSTOM CARDS FUNCTIONS =====
        function addCustomCard(type) {
            const cards = getCustomCards();
            
            if (type === 'black') {
                const text = document.getElementById('blackCardText').value.trim();
                if (!text) return;
                
                const pick = (text.match(/___/g) || []).length || 1;
                cards.black.push({ text, pick });
                document.getElementById('blackCardText').value = '';
            } else {
                const text = document.getElementById('whiteCardText').value.trim();
                if (!text) return;
                
                cards.white.push(text);
                document.getElementById('whiteCardText').value = '';
            }
            
            saveCustomCards(cards);
            updateCustomCardsList();
        }

        function updateCustomCardsList() {
            const cards = getCustomCards();
            const container = document.getElementById('customCardsList');
            
            container.innerHTML = `
                <h4>Black Cards (${cards.black.length})</h4>
                ${cards.black.map((card, i) => `
                    <div class="card black-card" style="font-size: 0.9em; margin: 5px 0;">
                        ${card.text}
                        <button onclick="removeCustomCard('black', ${i})" style="float: right; padding: 5px 10px;">Remove</button>
                    </div>
                `).join('')}
                
                <h4 style="margin-top: 20px;">White Cards (${cards.white.length})</h4>
                ${cards.white.map((card, i) => `
                    <div class="card" style="margin: 5px 0;">
                        ${card}
                        <button onclick="removeCustomCard('white', ${i})" style="float: right; padding: 5px 10px;">Remove</button>
                    </div>
                `).join('')}
            `;
        }

        function removeCustomCard(type, index) {
            const cards = getCustomCards();
            cards[type].splice(index, 1);
            saveCustomCards(cards);
            updateCustomCardsList();
        }

        // ===== QR CODE FUNCTIONS =====
        async function scanQRCode() {
            const modal = document.getElementById('qrModal');
            const video = document.getElementById('qrVideo');
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                video.srcObject = stream;
                modal.classList.add('active');
                
                const canvas = document.getElementById('qrCanvas');
                const context = canvas.getContext('2d');
                
                const scan = () => {
                    if (video.readyState === video.HAVE_ENOUGH_DATA) {
                        canvas.height = video.videoHeight;
                        canvas.width = video.videoWidth;
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);
                        
                        if (code) {
                            // Extract room code from URL
                            const url = new URL(code.data);
                            const roomCode = url.searchParams.get('room');
                            if (roomCode) {
                                document.getElementById('roomCodeInput').value = roomCode;
                                stopQRScanner();
                                joinRoom();
                            }
                        }
                    }
                    if (modal.classList.contains('active')) {
                        requestAnimationFrame(scan);
                    }
                };
                
                video.play();
                requestAnimationFrame(scan);
            } catch (error) {
                console.error('QR Scanner error:', error);
                alert('Unable to access camera');
            }
        }

        function stopQRScanner() {
            const modal = document.getElementById('qrModal');
            const video = document.getElementById('qrVideo');
            
            modal.classList.remove('active');
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
        }

        // ===== LOCAL STORAGE HELPERS =====
        function loadPlayerName() {
            const nameInput = document.getElementById('playerName');
            if (nameInput) {
                nameInput.value = localStorage.getItem('cah-player-name') || 'Player';
            }
        }

        function savePlayerName(name) {
            localStorage.setItem('cah-player-name', name);
        }

        function getCustomCards() {
            try {
                return JSON.parse(localStorage.getItem('cah-custom-cards')) || { black: [], white: [] };
            } catch {
                return { black: [], white: [] };
            }
        }

        function saveCustomCards(cards) {
            localStorage.setItem('cah-custom-cards', JSON.stringify(cards));
        }

        function loadCustomCards() {
            if (!localStorage.getItem('cah-custom-cards')) {
                saveCustomCards({ black: [], white: [] });
            }
            updateCustomCardsList();
        }

        function getSettings() {
            try {
                return JSON.parse(localStorage.getItem('cah-settings')) || { enableCustomCards: true };
            } catch {
                return { enableCustomCards: true };
            }
        }

        function loadSettings() {
            if (!localStorage.getItem('cah-settings')) {
                localStorage.setItem('cah-settings', JSON.stringify({ enableCustomCards: true }));
            }
            
            const notifications = localStorage.getItem('cah-notifications');
            if (notifications) {
                appState.notifications = JSON.parse(notifications);
            }
        }

        function loadTheme() {
            setTheme(localStorage.getItem('cah-theme') || 'midnight-gaming');
        }

        // ===== ATTRIBUTION PROTECTION =====
        function initializeCopyright() {
            console.log("%c© All Rights Reserved - Mathew Tyler", "color: #ff0000; font-size: 20px; font-weight: bold;");
            console.log("%cUnauthorized modification, reproduction, or redistribution is prohibited.", "color: #ff0000; font-size: 14px;");
            console.log("%cWebsite: https://tylerpresident.com | https://fakegov.com", "color: #4CAF50; font-size: 14px;");
        }

        function toggleAttribution() {
            document.getElementById('attributionFooter').classList.toggle('minimized');
        }

        function initializeAttribution() {
            if (window.innerWidth <= 768) {
                document.getElementById('attributionFooter').classList.add('minimized');
            }
        }

        function protectAttribution() {
            setInterval(() => {
                const footer = document.getElementById('attributionFooter');
                if (footer) {
                    const styles = window.getComputedStyle(footer);
                    if (styles.display === 'none' || styles.visibility === 'hidden') {
                        location.reload();
                    }
                } else {
                    location.reload();
                }
            }, 2000);
        }

        function observeAttribution() {
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    mutation.removedNodes.forEach(node => {
                        if (node.id === 'attributionFooter') {
                            location.reload();
                        }
                    });
                });
            });
            observer.observe(document.body, { childList: true, subtree: true });
        }

        // ===== URL PARAMETERS =====
        function checkUrlParams() {
            const params = new URLSearchParams(window.location.search);
            const roomCode = params.get('room');
            if (roomCode) {
                document.getElementById('roomCodeInput').value = roomCode;
                showScreen('joinMenu');
            }
        }

        // ===== ERROR HANDLING =====
        window.addEventListener('error', e => console.error('Global error:', e.error));
        window.addEventListener('unhandledrejection', e => console.error('Unhandled rejection:', e.reason));

        // ===== INITIALIZE APP =====
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            checkUrlParams();
        });
    </script>
</body>
</html>
